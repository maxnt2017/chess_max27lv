<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <title>Шахи - Повна версія</title>
    <style>
        /* ... (попередні стилі залишаються незмінними) ... */
        .promotion-dialog {
            position: absolute;
            background: white;
            border: 2px solid #333;
            padding: 10px;
            display: none;
            z-index: 100;
        }
        .promotion-piece {
            font-size: 30px;
            cursor: pointer;
            padding: 5px;
        }
    </style>
</head>
<body>
    <!-- ... (попередня розмітка залишається незмінною) ... -->

    <script>
        class ChessGame {
            constructor() {
                // ... (попередні властивості конструктора) ...
                this.inCheck = false;
            }

            getLegalMoves(x, y) {
                // ... (попередній код) ...
                switch(piece.type) {
                    case 'bishop':
                        this.addLineMoves(x, y, [[-1,-1],[-1,1],[1,-1],[1,1]], moves);
                        break;
                    case 'queen':
                        this.addLineMoves(x, y, 
                            [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[-1,1],[1,-1],[1,1]], 
                            moves);
                        break;
                    case 'king':
                        // Звичайні ходи
                        [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]].forEach(([dx, dy]) => {
                            if (this.validSquare(x+dx, y+dy) && 
                                this.board[x+dx][y+dy]?.color !== piece.color) {
                                moves.push({x: x+dx, y: y+dy});
                            }
                        });
                        // Рокіровка
                        if (piece.moved === false && !this.inCheck) {
                            // Коротка рокіровка
                            if (this.castling[piece.color].k &&
                                !this.board[x][5] && !this.board[x][6] &&
                                this.board[x][7]?.type === 'rook' && 
                                !this.board[x][7].moved) {
                                    moves.push({x, y: y+2, castle: true});
                            }
                            // Довга рокіровка
                            if (this.castling[piece.color].q &&
                                !this.board[x][1] && !this.board[x][2] && !this.board[x][3] &&
                                this.board[x][0]?.type === 'rook' && 
                                !this.board[x][0].moved) {
                                    moves.push({x, y: y-2, castle: true});
                            }
                        }
                        break;
                    // ... (інші фігури) ...
                }
                return moves.filter(move => !this.moveCausesCheck(x, y, move.x, move.y));
            }

            movePiece(fromX, fromY, toX, toY) {
                const piece = this.board[fromX][fromY];
                const target = this.board[toX][toY];
                
                // Взяття на проході
                if (piece.type === 'pawn' && Math.abs(fromY - toY) === 1 && !target) {
                    this.board[fromX][toY] = null;
                }
                
                // Рокіровка
                if (piece.type === 'king' && Math.abs(fromY - toY) === 2) {
                    const rookY = toY > fromY ? 7 : 0;
                    const newRookY = toY > fromY ? 5 : 3;
                    this.board[fromX][newRookY] = this.board[fromX][rookY];
                    this.board[fromX][rookY] = null;
                }

                // Переміщення фігури
                this.board[toX][toY] = {...piece, moved: true};
                this.board[fromX][fromY] = null;

                // Перевірка на перетворення пішака
                if (piece.type === 'pawn' && (toX === 0 || toX === 7)) {
                    this.promotePawn(toX, toY);
                }

                // Оновлення стану гри
                this.updateGameState();
            }

            promotePawn(x, y) {
                const dialog = document.getElementById('promotion-dialog');
                dialog.style.display = 'block';
                dialog.style.left = `${y * 70}px`;
                dialog.style.top = `${x * 70}px`;
                
                const pieces = ['♕', '♖', '♗', '♘'];
                dialog.innerHTML = pieces.map(p => 
                    `<div class="promotion-piece" onclick="game.finishPromotion(${x}, ${y}, '${p}')">${p}</div>`
                ).join('');
            }

            finishPromotion(x, y, symbol) {
                this.board[x][y].symbol = symbol;
                this.board[x][y].type = this.getPieceType(symbol);
                document.getElementById('promotion-dialog').style.display = 'none';
                this.updateUI();
            }

            isSquareAttacked(x, y, color) {
                // Перевірка чи клітинку атакує суперник
                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 8; j++) {
                        const piece = this.board[i][j];
                        if (piece && piece.color !== color) {
                            const moves = this.getRawMoves(i, j);
                            if (moves.some(m => m.x === x && m.y === y)) return true;
                        }
                    }
                }
                return false;
            }

            isCheck() {
                const kingPos = this.findKing(this.currentPlayer);
                return this.isSquareAttacked(kingPos.x, kingPos.y, this.currentPlayer);
            }

            isCheckmate() {
                if (!this.isCheck()) return false;
                return !this.hasLegalMoves();
            }

            findKing(color) {
                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 8; j++) {
                        if (this.board[i][j]?.type === 'king' && 
                           this.board[i][j]?.color === color) {
                            return {x: i, y: j};
                        }
                    }
                }
            }

            updateGameState() {
                this.inCheck = this.isCheck();
                if (this.isCheckmate()) alert('Мат!');
                // ... (оновлення інших станів) ...
            }
        }

        // ... (решта коду залишається незмінною) ...
    </script>
</body>
</html>
